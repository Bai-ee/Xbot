const openaiClient = require('../api/openaiClient.js');
const { BaseAgent } = require('./BaseAgent.js');
const { RECOMMENDED_PROMPT_PREFIX } = require('./HandoffManager.js');

// Content Creator Agent - Generates engaging Twitter content
class ContentCreatorAgent extends BaseAgent {
  constructor() {
    super('ContentCreator', ['content_creation', 'copywriting', 'social_media']);
  }

  async handleMessage(input, context = {}) {
    // Check if audio was generated by audio_generator agent
    const audioContext = this.extractAudioContext(context);
    
    const enhancedContext = {
      ...context,
      userProfile: context.profile || {},
      recentTweets: context.recentTweets || [],
      timestamp: new Date().toISOString()
    };

    // Add audio context if available
    if (audioContext) {
      enhancedContext.audioContext = audioContext;
      console.log(`üéµ ContentCreator using audio context: ${audioContext.audioArtist} - ${audioContext.audioMixTitle}`);
    }

    const result = await openaiClient.runSpecializedCompletion(
      'content_creator',
      input,
      enhancedContext
    );

    return {
      type: 'content',
      content: result.response,
      metadata: {
        model: result.model,
        usage: result.usage,
        agent: this.name,
        audioContext: audioContext ? {
          artist: audioContext.audioArtist,
          mixTitle: audioContext.audioMixTitle,
          duration: audioContext.audioDuration
        } : null
      }
    };
  }

  /**
   * Extract audio context from enriched context
   */
  extractAudioContext(context) {
    // Check if audio was already generated by audio_generator agent
    if (context.audioPath && context.audioFileName) {
      return {
        audioPath: context.audioPath,
        audioUrl: context.audioUrl,
        audioFileName: context.audioFileName,
        audioArtist: context.audioArtist,
        audioMixTitle: context.audioMixTitle,
        audioDuration: context.audioDuration,
        audioFileSize: context.audioFileSize,
        audioArweaveUrl: context.audioArweaveUrl,
        audioMetadata: context.audioMetadata,
        audioType: context.audioType
      };
    }
    
    // Also check in previousResults if this is a sequential workflow
    if (context.previousResults && Array.isArray(context.previousResults)) {
      for (const result of context.previousResults) {
        if (result.type === 'audio_generation' && result.success && result.audioPath) {
          return {
            audioPath: result.audioPath,
            audioUrl: result.url,
            audioFileName: result.fileName,
            audioArtist: result.artist,
            audioMixTitle: result.mixTitle,
            audioDuration: result.duration,
            audioFileSize: result.fileSize,
            audioArweaveUrl: result.arweaveUrl,
            audioMetadata: result.metadata,
            audioType: result.type
          };
        }
      }
    }
    
    return null;
  }
}

// Hashtag Specialist Agent - Optimizes hashtags for maximum reach
class HashtagSpecialistAgent extends BaseAgent {
  constructor() {
    super('HashtagSpecialist', ['hashtag_optimization', 'seo', 'trends']);
  }

  async handleMessage(input, context = {}) {
    const result = await openaiClient.runSpecializedCompletion(
      'hashtag_specialist',
      input,
      {
        ...context,
        currentTrends: context.trends || [],
        userNiche: context.niche || 'general',
        timestamp: new Date().toISOString()
      }
    );

    return {
      type: 'hashtags',
      hashtags: this.extractHashtags(result.response),
      recommendations: result.response,
      metadata: {
        model: result.model,
        usage: result.usage,
        agent: this.name
      }
    };
  }

  extractHashtags(text) {
    const hashtagRegex = /#[a-zA-Z0-9_]+/g;
    return text.match(hashtagRegex) || [];
  }
}

// Engagement Optimizer Agent - Maximizes engagement potential
class EngagementOptimizerAgent extends BaseAgent {
  constructor() {
    super('EngagementOptimizer', ['engagement', 'analytics', 'optimization']);
  }

  async handleMessage(input, context = {}) {
    const result = await openaiClient.runSpecializedCompletion(
      'engagement_optimizer',
      input,
      {
        ...context,
        analytics: context.analytics || {},
        followers: context.followers || 0,
        engagementHistory: context.engagementHistory || [],
        timestamp: new Date().toISOString()
      }
    );

    return {
      type: 'engagement_optimization',
      recommendations: result.response,
      optimizedContent: this.extractOptimizedContent(result.response),
      metadata: {
        model: result.model,
        usage: result.usage,
        agent: this.name
      }
    };
  }

  extractOptimizedContent(text) {
    // Simple extraction - in a real implementation, this would be more sophisticated
    const lines = text.split('\n');
    return lines.find(line => line.toLowerCase().includes('optimized') || line.includes('üëç')) || text;
  }
}

// Trend Analyst Agent - Analyzes trends and suggests trending content
class TrendAnalystAgent extends BaseAgent {
  constructor() {
    super('TrendAnalyst', ['trend_analysis', 'research', 'market_intelligence']);
  }

  async handleMessage(input, context = {}) {
    const result = await openaiClient.runSpecializedCompletion(
      'trend_analyst',
      input,
      {
        ...context,
        currentDate: new Date().toISOString().split('T')[0],
        userNiche: context.niche || 'general',
        recentAnalytics: context.analytics || {},
        timestamp: new Date().toISOString()
      }
    );

    return {
      type: 'trend_analysis',
      trends: this.extractTrends(result.response),
      analysis: result.response,
      contentSuggestions: this.extractContentSuggestions(result.response),
      metadata: {
        model: result.model,
        usage: result.usage,
        agent: this.name
      }
    };
  }

  extractTrends(text) {
    // Extract trending topics mentioned in the response
    const trendRegex = /#\w+|trending:\s*(.+)|trend:\s*(.+)/gi;
    const matches = text.match(trendRegex) || [];
    return matches.slice(0, 5); // Top 5 trends
  }

  extractContentSuggestions(text) {
    // Extract content suggestions from the response
    const lines = text.split('\n');
    return lines
      .filter(line => line.includes('üí°') || line.includes('suggestion') || line.includes('idea'))
      .slice(0, 3); // Top 3 suggestions
  }
}

// Scheduler Agent - Optimizes posting timing and frequency
class SchedulerAgent extends BaseAgent {
  constructor() {
    super('Scheduler', ['scheduling', 'timing_optimization', 'audience_analysis']);
  }

  async handleMessage(input, context = {}) {
    const result = await openaiClient.runSpecializedCompletion(
      'scheduler',
      input,
      {
        ...context,
        timezone: context.timezone || 'UTC',
        audienceLocation: context.audienceLocation || 'global',
        postingHistory: context.postingHistory || [],
        currentTime: new Date().toISOString(),
        timestamp: new Date().toISOString()
      }
    );

    return {
      type: 'scheduling',
      recommendations: result.response,
      optimalTimes: this.extractOptimalTimes(result.response),
      frequency: this.extractFrequency(result.response),
      metadata: {
        model: result.model,
        usage: result.usage,
        agent: this.name
      }
    };
  }

  extractOptimalTimes(text) {
    // Extract time recommendations
    const timeRegex = /\d{1,2}:\d{2}|\d{1,2}\s*(am|pm)/gi;
    return text.match(timeRegex) || [];
  }

  extractFrequency(text) {
    // Extract posting frequency recommendations
    const freqRegex = /\d+\s*(times?\s*)?(per|every)\s*(day|hour|week)/gi;
    const match = text.match(freqRegex);
    return match ? match[0] : 'No specific frequency mentioned';
  }
}

// Agent Factory - Creates and manages agent instances
class TwitterAgentFactory {
  constructor() {
    this.agents = new Map();
    this.initializeAgents();
  }

  initializeAgents() {
    // Create all specialized agents
    this.agents.set('content_creator', new ContentCreatorAgent());
    this.agents.set('hashtag_specialist', new HashtagSpecialistAgent());
    this.agents.set('engagement_optimizer', new EngagementOptimizerAgent());  
    this.agents.set('trend_analyst', new TrendAnalystAgent());
    this.agents.set('scheduler', new SchedulerAgent());

    // Initialize video generation agent
    try {
      const { ArweaveVideoAgent } = require('./ArweaveVideoAgent.js');
      this.agents.set('video_generator', new ArweaveVideoAgent());
      console.log('‚úÖ ArweaveVideoAgent initialized successfully');
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to initialize ArweaveVideoAgent:', error.message);
    }

    // Initialize audio generation agent
    try {
      const { ArweaveAudioAgent } = require('./ArweaveAudioAgent.js');
      this.agents.set('audio_generator', new ArweaveAudioAgent());
      console.log('‚úÖ ArweaveAudioAgent initialized successfully');
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to initialize ArweaveAudioAgent:', error.message);
    }

    // Initialize image generation agent
    try {
      const { ImageGenerationAgent } = require('./ImageGenerationAgent.js');
      this.agents.set('image_generator', new ImageGenerationAgent());
      console.log('‚úÖ ImageGenerationAgent initialized successfully');
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to initialize ImageGenerationAgent:', error.message);
    }

    console.log('ü§ñ Initialized Agents:', Array.from(this.agents.keys()));
  }

  getAgent(agentType) {
    const agent = this.agents.get(agentType);
    if (!agent) {
      throw new Error(`Agent not found: ${agentType}`);
    }
    return agent;
  }

  getAllAgents() {
    return Array.from(this.agents.values());
  }

  getAvailableAgentTypes() {
    return Array.from(this.agents.keys());
  }

  async healthCheckAll() {
    const results = {};
    for (const [type, agent] of this.agents) {
      results[type] = await agent.healthCheck();
    }
    return results;
  }

  getSystemStats() {
    const stats = {};
    for (const [type, agent] of this.agents) {
      stats[type] = agent.getStats();
    }
    return {
      totalAgents: this.agents.size,
      agentStats: stats,
      systemHealth: 'operational'
    };
  }
}

// Singleton factory instance
const twitterAgentFactory = new TwitterAgentFactory();

module.exports = { 
  BaseAgent,
  ContentCreatorAgent,
  HashtagSpecialistAgent,
  EngagementOptimizerAgent,
  TrendAnalystAgent,
  SchedulerAgent,
  TwitterAgentFactory,
  twitterAgentFactory
}; 